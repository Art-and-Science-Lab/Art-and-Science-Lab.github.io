<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>SI ⇔ ST ⇔ ST(Natural) Converter</title>
  <style>
    :root{ --bg:#fff; --text:#111827; --muted:#6b7280; --card:#f9fafb; --line:#e5e7eb; }
    body{ margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial; background:var(--bg); color:var(--text); }
    .wrap{ max-width:980px; margin:24px auto; padding:0 16px; }
    h1{ font-size:20px; margin:0 0 8px; }
    .muted{ color:var(--muted); font-size:12px; line-height:1.5; }
    .card{ background:var(--card); border:1px solid var(--line); border-radius:14px; padding:14px; margin-top:14px; }
    label{ display:block; font-size:12px; color:var(--muted); margin:0 0 6px; }
    select,input{ width:100%; padding:10px; border:1px solid var(--line); border-radius:10px; font-size:14px; background:#fff; }
    .row{ display:flex; gap:12px; flex-wrap:wrap; align-items:flex-end; }
    .col{ flex:1; min-width:260px; }
    .mono{ font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace; }
    .err{ color:#b00020; font-size:13px; margin-top:10px; display:none; }

    .inputWrap{ display:flex; gap:10px; align-items:center; }
    .unitLabel{
      white-space:nowrap;
      font-size:13px;
      color:#111827;
      padding:6px 10px;
      border:1px solid var(--line);
      border-radius:999px;
      background:#fff;
      line-height:1;
    }

    /* LaTeX-like fraction */
    .u{ display:inline-flex; align-items:flex-end; gap:6px; }
    .dot{ padding:0 2px; }
    .pow sup{ font-size:0.75em; vertical-align:super; }
    .frac{
      display:inline-flex;
      flex-direction:column;
      align-items:center;
      line-height:1.05;
      transform: translateY(-0.5px);
    }
    .frac .num{ padding:0 2px; }
    .frac .bar{ width:100%; border-top:1px solid #111827; margin:2px 0 1px; }
    .frac .den{ padding:0 2px; }
    .ok{ background:#fff; }
  </style>
</head>
<body>
<div class="wrap">
  <h1>SI単位 ⇔ ST単位 ⇔ ST自然単位 コンバーター</h1>
  <div class="muted">
    SI単位系 / ST単位系 / ST自然単位系 のどこに数値を入れても自動で相互変換します。
  </div>

    <div class="row">
    <div class="col">
        <label>量</label>
        <select id="quantity"></select>
    </div>

    <div class="col">
        <label>定数</label>
        <select id="constant"></select>
    </div>
    </div>


    <div class="row" style="margin-top:12px;">
      <div class="col">
        <label>SI 単位系</label>
        <div class="inputWrap">
          <input id="siValue" placeholder="例: 1.23e-4" />
          <span class="unitLabel" id="siUnit">—</span>
        </div>
      </div>

      <div class="col">
        <label>ST 単位系</label>
        <div class="inputWrap">
          <input id="stValue" placeholder="例: 1.23e-4" />
          <span class="unitLabel" id="stUnit">—</span>
        </div>
      </div>

      <div class="col">
        <label>ST 自然単位系</label>
        <div class="inputWrap">
          <input id="stnValue" placeholder="例: 1.23e-4" />
          <span class="unitLabel" id="stnUnit">—</span>
        </div>
      </div>
    </div>

    <div id="customBox" class="card ok" style="display:none; margin-top:12px;">
      <div class="muted">Custom: <span class="mono">kg^a · C^b · m^c · s^d</span> の指数（整数）を入力</div>
      <div class="row" style="margin-top:10px;">
        <div class="col"><label>a (kg)</label><input id="a" value="0"></div>
        <div class="col"><label>b (C)</label><input id="b" value="0"></div>
        <div class="col"><label>c (m)</label><input id="c" value="0"></div>
        <div class="col"><label>d (s)</label><input id="d" value="0"></div>
      </div>
    </div>

    <div id="err" class="err"></div>
  </div>
</div>

<script>
  // ---- SI constants ----
  const MU0 = 4 * Math.PI * 1e-7;   // N/A^2
  const MUc = MU0 / (4 * Math.PI);  // 1e-7
  const e  = 1.602176634e-19;       // C
  const c0 = 299792458;             // m/s
  const me = 9.1093837e-31;      // kg
  // Your ST definitions:
  // e_m = e*c/m_e
  // γ = μc * e_m
  // δ = μc * e_m^2
  const em = e * c0 / me;
  const gamma = MUc * em;
  const delta = MUc * em * em;

  // ---- ST Natural (use classical electron radius) ----
  // r_e = μc * e^2 / m_e  (since 1/(4π ε0) = μ0 c^2 /(4π) = μc c^2)
  const re = MUc * (e * e) / me;  // meters
  const te = re / c0;              // seconds

    const fmt = (x) => {
    if (!isFinite(x)) return "";
    if (x === 0) return "0";
    const r = Math.round(x);
    if ((r !== 0 || Math.abs(x) >= 0.5) && Math.abs(x - r) < 1e-9) {
        return r.toString();
    }
    const ax = Math.abs(x);
    if (ax >= 1e6 || ax < 1e-3) return x.toExponential(6);
    return (Math.round(x * 1e12) / 1e12).toString();
    };  

  function parseNum(s){
    s = (s||"").trim();
    if (!s) return null;
    if (!/^[+-]?(\d+(\.\d*)?|\.\d+)([eE][+-]?\d+)?$/.test(s)) return null;
    return Number(s);
  }
  function parseIntStrict(s){
    s = (s||"").trim();
    if (!/^[+-]?\d+$/.test(s)) return null;
    return parseInt(s,10);
  }

  // exp = [kgExp, CExp, mExp, sExp]
  function unitHTMLFromExp(exp){
    const names = ["kg","C","m","s"];
    const num = [];
    const den = [];

    const termHTML = (name, pAbs) => {
      if (pAbs === 1) return `<span class="pow">${name}</span>`;
      return `<span class="pow">${name}<sup>${pAbs}</sup></span>`;
    };

    for (let i=0; i<4; i++){
      const p = exp[i];
      if (p === 0) continue;
      const t = termHTML(names[i], Math.abs(p));
      if (p > 0) num.push(t);
      else den.push(t);
    }

    const joinDot = (arr) => arr.join(`<span class="dot">·</span>`);
    const n = num.length ? joinDot(num) : `<span class="pow">1</span>`;

    if (!den.length){
      return `<span class="u">${n}</span>`;
    }

    const d = joinDot(den);
    return `
      <span class="u">
        <span class="frac">
          <span class="num">${n}</span>
          <span class="bar"></span>
          <span class="den">${d}</span>
        </span>
      </span>
    `;
  }

  // ST Natural unit label: show r_e and (r_e/c)
  // stExp = [0,0,M,S] corresponds to m^M s^S in ST
  function unitHTML_STN_fromStExp(stExp){
    const M = stExp[2];
    const S = stExp[3];

    const num = [];
    const den = [];

    const termHTML = (name, pAbs) => {
      if (pAbs === 1) return `<span class="pow">${name}</span>`;
      return `<span class="pow">${name}<sup>${pAbs}</sup></span>`;
    };

    // basis: r_e (length), t_e = r_e/c (time)
    if (M !== 0){
      const t = termHTML("L", Math.abs(M));
      (M > 0 ? num : den).push(t);
    }
    if (S !== 0){
      const t = termHTML("T", Math.abs(S));
      (S > 0 ? num : den).push(t);
    }

    const joinDot = (arr) => arr.join(`<span class="dot">·</span>`);
    const n = num.length ? joinDot(num) : `<span class="pow">1</span>`;

    if (!den.length){
      return `<span class="u">${n}</span>`;
    }

    const d = joinDot(den);
    return `
      <span class="u">
        <span class="frac">
          <span class="num">${n}</span>
          <span class="bar"></span>
          <span class="den">${d}</span>
        </span>
      </span>
    `;
  }

  // SI -> ST absorbs kg and C into (m,s)
  function siExpToStExp(siExp){
    const [kgExp, cExp, mExp, sExp] = siExp;
    const m2 = mExp + 3*kgExp + 2*cExp;
    const s2 = sExp - 2*kgExp - 1*cExp;
    return [0, 0, m2, s2];
  }

  // numeric scale factor SI -> ST
  function scaleFactor_SI_to_ST(kgExp, cExp){
    let f = 1;
    if (kgExp !== 0) f *= Math.pow(delta, kgExp);
    if (cExp  !== 0) f *= Math.pow(gamma, cExp);
    return f;
  }

  // ST <-> ST Natural scaling (depends only on ST exponents M,S)
  // Q = v_st * m^M s^S = v_n * r_e^M t_e^S
  function stToStn(v_st, stExp){
    const M = stExp[2], S = stExp[3];
    const scale = Math.pow(re, M) * Math.pow(te, S);
    return v_st / scale;
  }
  function stnToSt(v_n, stExp){
    const M = stExp[2], S = stExp[3];
    const scale = Math.pow(re, M) * Math.pow(te, S);
    return v_n * scale;
  }

  // ---- Quantities ----
const quantities = {
  length_m:   { label:"Length",       si:"m",         exp:[ 0, 0, 1, 0] },
  time_s:     { label:"Time",         si:"s",         exp:[ 0, 0, 0, 1] },
  velocity:  { label:"Velocity",     si:"m/s",       exp:[ 0, 0, 1,-1] },
  acceleration: { label:"Acceleration", si:"m/s^2", exp:[0,0,1,-2] },
  mass_kg:  { label:"Mass",        si:"kg",        exp:[ 1, 0, 0, 0] },
  momentum_p: { label:"Momentum", si:"p = kg·m/s", exp:[1,0,1,-1] },
  force_N:  { label:"Force",       si:"N",         exp:[ 1, 0, 1,-2] },
  energy_J: { label:"Energy",      si:"J",         exp:[ 1, 0, 2,-2] },
  power_W:  { label:"Power",       si:"W",         exp:[ 1, 0, 2,-3] },
  charge_C: { label:"Charge",      si:"C",         exp:[ 0, 1, 0, 0] },
  current_A:{ label:"Current",     si:"A = C/s",   exp:[ 0, 1, 0,-1] },
  voltage_V:{ label:"Voltage",     si:"V = J/C",   exp:[ 1,-1, 2,-2] },
  resistance_Ohm:{label:"Resistance", si:"Ω = V/A", exp:[ 1,-2, 2,-1] },
  capacitance_F:{label:"Capacitance", si:"F = C/V", exp:[-1, 2,-2, 2] },
  electricField: { label:"Electric field",  si:"V/m",          exp:[ 1,-1, 1,-2] },
  magneticField:{ label:"Magnetic field",  si:"T = V·s/m^2",  exp:[ 1,-1, 0,-1] },
  custom:   { label:"Custom",      si:"kg^a·C^b·m^c·s^d", exp:[ 0, 0, 0, 0] },
};

// ---- Constants (dropdown injects SI value + switches quantity) ----
const constants = {
  none: { label:"—", quantityKey:"", siValue:"" }, // 空欄
  c0:   { label:"Speed of light (c)",      quantityKey:"velocity", siValue: c0 },
  e0:   { label:"Elementary charge (e)",  quantityKey:"charge_C", siValue: e  },
};

  const qSel   = document.getElementById("quantity");
  const cSel   = document.getElementById("constant");
  const siIn   = document.getElementById("siValue");
  const stIn   = document.getElementById("stValue");
  const stnIn  = document.getElementById("stnValue");
  const siUnit = document.getElementById("siUnit");
  const stUnit = document.getElementById("stUnit");
  const stnUnit= document.getElementById("stnUnit");
  const errEl  = document.getElementById("err");
  const customBox = document.getElementById("customBox");

    {
    const opt = document.createElement("option");
    opt.value = "";
    opt.textContent = "—";
    qSel.appendChild(opt);
    }
    Object.entries(quantities).forEach(([k,v])=>{
    const opt = document.createElement("option");
    opt.value = k;
    opt.textContent = `${v.label} (${v.si})`;
    qSel.appendChild(opt);
    });

    Object.entries(constants).forEach(([k,v])=>{
    const opt = document.createElement("option");
    opt.value = k;
    opt.textContent = v.label;
    cSel.appendChild(opt);
    });
    cSel.value = "none"; 



  function showErr(msg){
    errEl.textContent = msg;
    errEl.style.display = "block";
  }

    function getCurrentSiExp(){
    const key = qSel.value;
    if (!key) return null; 

    let exp = quantities[key].exp.slice();

    if (key === "custom"){
        const a = parseIntStrict(document.getElementById("a").value);
        const b = parseIntStrict(document.getElementById("b").value);
        const c = parseIntStrict(document.getElementById("c").value);
        const d = parseIntStrict(document.getElementById("d").value);
        if ([a,b,c,d].some(x=>x===null)) return null;
        exp = [a,b,c,d];
    }
    return exp;
    }

    function refreshUnits(){
    errEl.style.display = "none";

    if (!qSel.value){
        customBox.style.display = "none";
        siUnit.textContent  = "—";
        stUnit.textContent  = "—";
        stnUnit.textContent = "—";
        return;
    }

    const key = qSel.value;
    customBox.style.display = (key === "custom") ? "block" : "none";

    const siExp = getCurrentSiExp();
    if (!siExp){
        siUnit.textContent = "—";
        stUnit.textContent = "—";
        stnUnit.textContent = "—";
        return;
    }
    const stExp = siExpToStExp(siExp);

    siUnit.innerHTML  = unitHTMLFromExp(siExp);
    stUnit.innerHTML  = unitHTMLFromExp(stExp);
    stnUnit.innerHTML = unitHTML_STN_fromStExp(stExp);
    }

  let isUpdating = false;

  function convertFromSI(){
    if (isUpdating) return;
    errEl.style.display = "none";

    const siExp = getCurrentSiExp();
    if (!siExp) { showErr("Custom指数は整数で入力してください。"); return; }

    const val = parseNum(siIn.value);
    if (val === null){
      if (!siIn.value.trim()){
        isUpdating = true; stIn.value = ""; stnIn.value = ""; isUpdating = false;
        return;
      }
      showErr("SI側の数値が不正です（例: 1.23e-4）");
      return;
    }

    const stExp = siExpToStExp(siExp);
    const [kgExp, cExp] = siExp;
    const f = scaleFactor_SI_to_ST(kgExp, cExp);

    const v_st  = val * f;
    const v_stn = stToStn(v_st, stExp);

    isUpdating = true;
    stIn.value  = fmt(v_st);
    stnIn.value = fmt(v_stn);
    isUpdating = false;
  }

  function convertFromST(){
    if (isUpdating) return;
    errEl.style.display = "none";

    const siExp = getCurrentSiExp();
    if (!siExp) { showErr("Custom指数は整数で入力してください。"); return; }

    const val = parseNum(stIn.value);
    if (val === null){
      if (!stIn.value.trim()){
        isUpdating = true; siIn.value = ""; stnIn.value = ""; isUpdating = false;
        return;
      }
      showErr("ST側の数値が不正です（例: 1.23e-4）");
      return;
    }

    const stExp = siExpToStExp(siExp);
    const [kgExp, cExp] = siExp;
    const f = scaleFactor_SI_to_ST(kgExp, cExp);

    const v_si  = val / f;
    const v_stn = stToStn(val, stExp);

    isUpdating = true;
    siIn.value  = fmt(v_si);
    stnIn.value = fmt(v_stn);
    isUpdating = false;
  }

  function convertFromSTN(){
    if (isUpdating) return;
    errEl.style.display = "none";

    const siExp = getCurrentSiExp();
    if (!siExp) { showErr("Custom指数は整数で入力してください。"); return; }

    const val = parseNum(stnIn.value);
    if (val === null){
      if (!stnIn.value.trim()){
        isUpdating = true; siIn.value = ""; stIn.value = ""; isUpdating = false;
        return;
      }
      showErr("ST自然側の数値が不正です（例: 1.23e-4）");
      return;
    }

    const stExp = siExpToStExp(siExp);
    const v_st = stnToSt(val, stExp);

    const [kgExp, cExp] = siExp;
    const f = scaleFactor_SI_to_ST(kgExp, cExp);
    const v_si = v_st / f;

    isUpdating = true;
    stIn.value = fmt(v_st);
    siIn.value = fmt(v_si);
    isUpdating = false;
  }

  // events
    cSel.addEventListener("change", ()=>{
    const ck = cSel.value;
    const cdef = constants[ck];
    if (!cdef || ck === "none") return;

    qSel.value = cdef.quantityKey;

    refreshUnits();

    isUpdating = true;
    siIn.value = fmt(Number(cdef.siValue));
    stIn.value = "";
    stnIn.value = "";
    isUpdating = false;

    convertFromSI();
    });

  qSel.addEventListener("change", ()=>{
    cSel.value = "none";
    refreshUnits();
    if (siIn.value.trim()) convertFromSI();
    else if (stIn.value.trim()) convertFromST();
    else if (stnIn.value.trim()) convertFromSTN();
  });

  ["a","b","c","d"].forEach(id=>{
    const el = document.getElementById(id);
    el.addEventListener("input", ()=>{
      refreshUnits();
      if (siIn.value.trim()) convertFromSI();
      else if (stIn.value.trim()) convertFromST();
      else if (stnIn.value.trim()) convertFromSTN();
    });
  });

  siIn.addEventListener("input", convertFromSI);
  stIn.addEventListener("input", convertFromST);
  stnIn.addEventListener("input", convertFromSTN);

  // init
  refreshUnits();
</script>
</body>
</html>
